# TechRUs - https://techrus.dev

## Project Proposal

TechRUs is an enterprise e-commerce platform which is built with the purpose of selling electronic products to customers such as TVs, PS5 Video Games, External storage drives, tablets and so much more. TechRUs is a platform that is developed with a focus on the MVC, Microservices and client/server architecture. Generally, most applications are developed using the monolithic architectural style. However as the size of the codebase grows in size over time, then these types of applications become very hard to manage by developers working as part of a team. Making them without a doubt very difficult to understand. Another problem with monolithic style applications is inevitably scalability. 

Web applications which use the monolithic architecture are an increasingly popular approach for developing smaller projects with fewer features to develop. Monolithic applications are very simple to develop in the short-term whilst there’s not much code to be written for certain features in the beginning. However, in in the long term, using the monolithic approach causes significant development problems, one of them being scalability. This is due to certain factors such as lack of cohesion, scalability, robustness, and availability within the codebase which makes it difficult for developers to maintain a larger codebase. Moreover, enterprise style systems such as e-commerce stores which is a type of enterprise system which is going to be developed, tested, deployed, and evaluated are hard to maintain with this kind of architecture with regards to code modularity and lack of coupling between components. To overcome the issues that monolithic applications come with, we can instead convert the large codebase into smaller and standalone modules which fit into their own respective microservice. Each microservice has its own single source of truth making the application more modular, scalable, and robust as the code grows. Furthermore, this report is split up into several sections which describes and closely analyses the certain tasks which are going to be implemented with regards to the development of the e-commerce store.

The component mining section is going to outline various component descriptions with regards to the requirements with interface descriptions for each component. These include certain semantics such as the pre and post condition assertions which must hold true when the component carries out its task. The interfaces are also going to describe its provides and requires interface definitions which describes what the component does and what services are offered. Also, the monolithic to microservices section describes and evaluates the approaches taken to switch from the typical monolithic codebase into microservices. Furthermore, the microservices approach design is going to show some coherent diagrams that represents which services the e-commerce store is going to be using to fulfil the requirements. And, how they communicate with each other using coupling. After this section, the test-driven development approach is going to discuss and analyse the benefits of writing coherent test cases before certain features are implemented. The test plans are also going to be created for every single standalone microservice to prevent unforeseen errors from arising during development.

# Component Mining Approach

The e-commerce platform is going to be developed using multiple reusable components that makes the application more modular and maintainable. The first component which is going to be described in detail is the login component which is linked to the standalone authentication microservice. It is important that users create their account using some unique credentials in the form of username, e-mail address and their password before placing orders for one or more products. Users can login only with their e-mail and password to prevent unauthorized from malicious users. Below is a description of the login component and its interfaces. The login component is important for this system because it is a must have requirement for this project whereby staff users must authenticate before adding their shipping details, place an order for a product and pay for the product.

## Component Name: Login Module

Component Description: The purpose of the login module is to allow staff users to authenticate to the system securely using sensitive credentials such as their e-mail address and password. Every time a single user attempts to login into the system, the component is going to check to see if the correct e-mail and password is provided by the user against the data stored inside the authentication database. Moreover, this component includes a server-side validation check that determines if the input data is feasible and in the correct format before logging the user in. However, this information is hidden from the end-user. Otherwise, if an incorrect e-mail address or password is provided, the authentication service returns a 400 bad request status code. Also, the module is going to query the authentication database to ensure that the e-mail address provided by the user in the body of the request currently exists in the schema. Otherwise, an error message is going to be returned to the user saying that the e-mail address provided does not exist should this assertion render true. This is another piece of information that’s hidden from the user. The final check that this module is going to undertake is an asynchronous password comparison before ultimately logging in the user. Once the user inputs their plaintext password into the password input field and clicks the login button, the current password is asynchronously compared against the plaintext password by making a call to the authentication schema which compares the entered plaintext password against the user’s hashed one. If they both match, the login module generates a unique JSON Web Token (JWT) that is randomly generated and assigned to that user to identify the user.

Login Module Interface Description: The login module has a couple of services which defines the various functions this module has to offer. Firstly, the login module validates the user’s e-mail address and password. Also, selecting the current user’s e-mail address from the authentication schema by querying the authentication database. It checks to see if the current user exists and compares login passwords before fully authenticating the user into the platform. Finally, the requires interface for this component is that the login module must generate a unique JWT token for the user if the login operation was successful and attaches it to the user’s cookie. The other requires interface is that the login module provides a service that sends the logged in user a two-factor verification code to the user’s e-mail inbox to verify their account for enhanced security. Figure 1.0 below is a diagram that represents the above interface descriptions.

The login module is to be reused from another previous project and developed using the JavaScript programming language, which uses the Express JS framework for the backend and React JS as the frontend library that is responsible for rendering the login component user interface on the login page. Also, the most important safety conditions that must be met before the user logs in is that the user’s e-mail address exists, and the passwords are properly compared, otherwise the user will receive an error saying that either the password is incorrect, or the e-mail address is invalid by the server.

Pre-Condition 1:  E-mail address and password inputs are valid AND user e-mail address selected from authentication database.

Pre-Condition 2: User account exists AND user’s entered password matches hashed password in the database.

Post-Condition 1: User e-mail address and password combination are valid AND user logged into the system.

Post-Condition 2: User is assigned unique JSON Web Token AND user can logout.

Post-Condition 3: Authentication Service server returns with a 200 OK status code.

The login component must be able to fulfil a time condition for the outlined services above. Users must be able to login into the system in less than 5 seconds with no extra delay, otherwise something may have potentially gone wrong on the server-side or client-side. Finally, the login component is going to have an exception handling mechanism that checks for potential errors using try and catch statements. The code that will perform its required tasks is going to be implemented within the try block and if any errors arise during the login process, then they are returned to the user in the form of an alert. The next component is going to describe how the products microservice provides several functions such as listing products which is responsible for presenting users that are accessing the e-commerce store with new products that have just arrived, which they can view the details and add to their basket. Finally, the next component that is going to be described is the create product component. 

## Component Name: Create Product Module

Component Description: The purpose of the create product component is to allow the store manager to monitor how much stock is available from the stores inventory system by creating products from a dashboard that does not allow regular users to access. Therefore, the products service component is going to have its own database schema which stores product data in the form of JSON data. Creating a new product to be added in stock requires a couple of steps to be undertaken. Firstly, the component is responsible for receiving several data inputs such as the name, description, warranty, price, stock count and whether the product is new or not which will come in the body of the request whenever the create product form is filled by the store manager. Furthermore, the component is going to check if the current product stock is less than the pre-defined value of 3 which is the initial value set for low stock for this platform, however this is subject to change in the future. If this assertion is true, then the component provides a service that sends an e-mail to the store managers inbox saying that the product is low in stock. Validation of the product details into the create product form is going to be another function provided by this component. Should the manager leave one of the input fields empty or provide the wrong data type for an attribute, then the server is going to return a 400 bad request error indicating that one or more input fields are missing, or the wrong data has been provided. This is to prevent redundant data from being written to the products schema.

Furthermore, if all the outlined preconditions are met and not violated, then a new product object is instantiated and saved to the products schema. After the server returns a status code of 201 which means that a new product resource has been created successfully on the server-side. Alongside the mentioned status code, the server also returns a response which includes the newly created product in the form of JSON. Thereafter, after the create product component creates the object and saves it to the database, it is also going to be responsible for dispatching an event of type product created with a specific Boolean parameter such as loading set to false. This means that the operation of creating a product is not currently loading any server-side data and has been successfully created. Global state management using redux is used for keeping track of all the products that are in stock, storing them in a products array. Below is an interface description for the create product reusable component. Which outlines its pre and post conditions, safety conditions, time conditions, the programming language and framework used to develop this component which in turn is one microservice.


Create Product Interface Description: The create product component has several functions that it provides for a new product to be created successfully without any errors being thrown, such as receiving data inputs for creating a new product in the body of the create product form. Another service provided by this component is storing the products in an array that can be accessed and manipulated globally within the frontend of the application. Every time a product is created, it is written to the array as state which keeps track of all the data for that product along with a unique ID. Therefore, the provides interface for this component is to allow the store manager to create a new product by inputting its data into a form. Also, before storing the data regarding the newly created product in the global state array called products, the component also provides a service that validates the current stock count of the product and other input fields such as name, description, and price. Furthermore, the requires interface for this component is to send a low stock e-mail to the inbox of the manager if the current product has low stock and if a product is out of stock. If the stock count variable is set to 0, a separate e-mail is sent to the inbox of the manager saying that more stock is going to be ordered. Figure 1.1 below is a diagram that represents the above interface descriptions for the create product component.


Create Product Interface Description: The create product component has several functions that it provides for a new product to be created successfully without any errors being thrown, such as receiving data inputs for creating a new product in the body of the create product form. Another service provided by this component is storing the products in an array that can be accessed and manipulated globally within the frontend of the application. Every time a product is created, it is written to the array as state which keeps track of all the data for that product along with a unique ID. Therefore, the provides interface for this component is to allow the store manager to create a new product by inputting its data into a form. Also, before storing the data regarding the newly created product in the global state array called products, the component also provides a service that validates the current stock count of the product and other input fields such as name, description, and price. Furthermore, the requires interface for this component is to send a low stock e-mail to the inbox of the manager if the current product has low stock and if a product is out of stock. If the stock count variable is set to 0, a separate e-mail is sent to the inbox of the manager saying that more stock is going to be ordered. Figure 1.1 below is a diagram that represents the above interface descriptions for the create product component.

The create product component is to be developed solely using the JavaScript programming language, which utilises the Express JS framework for the backend and React JS as the frontend library which is going to be launched as a standalone microservice using Docker, also known as the frontend service. Moreover, these technologies are responsible for developing the create product component and rendering the data to the users through the frontend interface on the products page by interacting with the products backend service. Also, the most important safety conditions that must be met before the store manager is able to create a new product is that the name, description, price, and stock count input data is validated properly on the server-side, otherwise the server will throw an error back to the client and the component should validate the data being entered to prevent any errors and inconsistencies in the database. Below are all the pre and post condition assertions that the create product component must meet for the operations to succeed.

Pre-Condition 1:  The request body contains the required fields for creating a new product. Such as the name, description, price, stock count and is new property AND stock count >= 0

Post-Condition 1: New product created AND data written to the products database.

Post-Condition 2: Product details along with a success message are both returned with a 201 created resource status code.

Post-Condition 3: Stock count < 3 then low stock e-mail is sent to the manager inbox using an e-mail transporter using event broker.

Post-Condition 4: If any of the input fields are missing, an error message is returned in the response with a status code of 400 Bad Request.

The time condition for this create product component is that a new product must be created in less than 10 milliseconds without any timeouts coming from any upstream server. Finally, the next component description within this report is used to describe the concept of the product details component and its interface which renders new product promotions to the users on the platform.



## Products - User Interface

The figure below shows the available products that are available to leave reviews and create orders for after adding one or more products to basket. This page is developed using two reusable components, one being the search bar that allows users to search for a product and the products that can be viewed in the middle of the page.

<img width="550" alt="image" src="https://user-images.githubusercontent.com/29733613/230411959-6f0d1b97-f193-4210-85b5-b72071ade1eb.png">
