# TechRUs - https://techrus.dev

# Project Proposal

TechRUs is an enterprise e-commerce platform which is built with the purpose of selling electronic products to customers such as TVs, PS5 Video Games, External storage drives, tablets and so much more. TechRUs is a platform that is developed with a focus on the MVC, Microservices and client/server architecture. Generally, most applications are developed using the monolithic architectural style. However as the size of the codebase grows in size over time, then these types of applications become very hard to manage by developers working as part of a team. Making them without a doubt very difficult to understand. Another problem with monolithic style applications is inevitably scalability. 

Web applications which use the monolithic architecture are an increasingly popular approach for developing smaller projects with fewer features to develop. Monolithic applications are very simple to develop in the short-term whilst there’s not much code to be written for certain features in the beginning. However, in in the long term, using the monolithic approach causes significant development problems, one of them being scalability. This is due to certain factors such as lack of cohesion, scalability, robustness, and availability within the codebase which makes it difficult for developers to maintain a larger codebase. Moreover, enterprise style systems such as e-commerce stores which is a type of enterprise system which is going to be developed, tested, deployed, and evaluated are hard to maintain with this kind of architecture with regards to code modularity and lack of coupling between components. To overcome the issues that monolithic applications come with, we can instead convert the large codebase into smaller and standalone modules which fit into their own respective microservice. Each microservice has its own single source of truth making the application more modular, scalable, and robust as the code grows. Furthermore, this report is split up into several sections which describes and closely analyses the certain tasks which are going to be implemented with regards to the development of the e-commerce store.

The component mining section is going to outline various component descriptions with regards to the requirements with interface descriptions for each component. These include certain semantics such as the pre and post condition assertions which must hold true when the component carries out its task. The interfaces are also going to describe its provides and requires interface definitions which describes what the component does and what services are offered. Also, the monolithic to microservices section describes and evaluates the approaches taken to switch from the typical monolithic codebase into microservices. Furthermore, the microservices approach design is going to Bushow some coherent diagrams that represents which services the e-commerce store is going to be using to fulfil the requirements. And, how they communicate with each other using coupling. After this section, the test-driven development approach is going to discuss and analyse the benefits of writing coherent test cases before certain features are implemented. The test plans are also going to be created for every single standalone microservice to prevent unforeseen errors from arising during development.

# Component Mining Approach

The e-commerce platform is going to be developed using multiple reusable components that makes the application more modular and maintainable. The first component which is going to be described in detail is the login component which is linked to the standalone authentication microservice. It is important that users create their account using some unique credentials in the form of username, e-mail address and their password before placing orders for one or more products. Users can login only with their e-mail and password to prevent unauthorized from malicious users. Below is a description of the login component and its interfaces. The login component is important for this system because it is a must have requirement for this project whereby staff users must authenticate before adding their shipping details, place an order for a product and pay for the product.

## Component Name: Login Module

Component Description: The purpose of the login module is to allow staff users to authenticate to the system securely using sensitive credentials such as their e-mail address and password. Every time a single user attempts to login into the system, the component is going to check to see if the correct e-mail and password is provided by the user against the data stored inside the authentication database. Moreover, this component includes a server-side validation check that determines if the input data is feasible and in the correct format before logging the user in. However, this information is hidden from the end-user. Otherwise, if an incorrect e-mail address or password is provided, the authentication service returns a 400 bad request status code. Also, the module is going to query the authentication database to ensure that the e-mail address provided by the user in the body of the request currently exists in the schema. Otherwise, an error message is going to be returned to the user saying that the e-mail address provided does not exist should this assertion render true. This is another piece of information that’s hidden from the user. The final check that this module is going to undertake is an asynchronous password comparison before ultimately logging in the user. Once the user inputs their plaintext password into the password input field and clicks the login button, the current password is asynchronously compared against the plaintext password by making a call to the authentication schema which compares the entered plaintext password against the user’s hashed one. If they both match, the login module generates a unique JSON Web Token (JWT) that is randomly generated and assigned to that user to identify the user.

Login Module Interface Description: The login module has a couple of services which defines the various functions this module has to offer. Firstly, the login module validates the user’s e-mail address and password. Also, selecting the current user’s e-mail address from the authentication schema by querying the authentication database. It checks to see if the current user exists and compares login passwords before fully authenticating the user into the platform. Finally, the requires interface for this component is that the login module must generate a unique JWT token for the user if the login operation was successful and attaches it to the user’s cookie. The other requires interface is that the login module provides a service that sends the logged in user a two-factor verification code to the user’s e-mail inbox to verify their account for enhanced security. Figure 1.0 below is a diagram that represents the above interface descriptions.

The login module is to be reused from another previous project and developed using the JavaScript programming language, which uses the Express JS framework for the backend and React JS as the frontend library that is responsible for rendering the login component user interface on the login page. Also, the most important safety conditions that must be met before the user logs in is that the user’s e-mail address exists, and the passwords are properly compared, otherwise the user will receive an error saying that either the password is incorrect, or the e-mail address is invalid by the server.

Pre-Condition 1:  E-mail address and password inputs are valid AND user e-mail address selected from authentication database.

Pre-Condition 2: User account exists AND user’s entered password matches hashed password in the database.

Post-Condition 1: User e-mail address and password combination are valid AND user logged into the system.

Post-Condition 2: User is assigned unique JSON Web Token AND user can logout.

Post-Condition 3: Authentication Service server returns with a 200 OK status code.

The login component must be able to fulfil a time condition for the outlined services above. Users must be able to login into the system in less than 5 seconds with no extra delay, otherwise something may have potentially gone wrong on the server-side or client-side. Finally, the login component is going to have an exception handling mechanism that checks for potential errors using try and catch statements. The code that will perform its required tasks is going to be implemented within the try block and if any errors arise during the login process, then they are returned to the user in the form of an alert. The next component is going to describe how the products microservice provides several functions such as listing products which is responsible for presenting users that are accessing the e-commerce store with new products that have just arrived, which they can view the details and add to their basket. Finally, the next component that is going to be described is the create product component. 

## Component Name: Create Product Module

Component Description: The purpose of the create product component is to allow the store manager to monitor how much stock is available from the stores inventory system by creating products from a dashboard that does not allow regular users to access. Therefore, the products service component is going to have its own database schema which stores product data in the form of JSON data. Creating a new product to be added in stock requires a couple of steps to be undertaken. Firstly, the component is responsible for receiving several data inputs such as the name, description, warranty, price, stock count and whether the product is new or not which will come in the body of the request whenever the create product form is filled by the store manager. Furthermore, the component is going to check if the current product stock is less than the pre-defined value of 3 which is the initial value set for low stock for this platform, however this is subject to change in the future. If this assertion is true, then the component provides a service that sends an e-mail to the store managers inbox saying that the product is low in stock. Validation of the product details into the create product form is going to be another function provided by this component. Should the manager leave one of the input fields empty or provide the wrong data type for an attribute, then the server is going to return a 400 bad request error indicating that one or more input fields are missing, or the wrong data has been provided. This is to prevent redundant data from being written to the products schema.

Furthermore, if all the outlined preconditions are met and not violated, then a new product object is instantiated and saved to the products schema. After the server returns a status code of 201 which means that a new product resource has been created successfully on the server-side. Alongside the mentioned status code, the server also returns a response which includes the newly created product in the form of JSON. Thereafter, after the create product component creates the object and saves it to the database, it is also going to be responsible for dispatching an event of type product created with a specific Boolean parameter such as loading set to false. This means that the operation of creating a product is not currently loading any server-side data and has been successfully created. Global state management using redux is used for keeping track of all the products that are in stock, storing them in a products array. Below is an interface description for the create product reusable component. Which outlines its pre and post conditions, safety conditions, time conditions, the programming language and framework used to develop this component which in turn is one microservice.

Create Product Interface Description: The create product component has several functions that it provides for a new product to be created successfully without any errors being thrown, such as receiving data inputs for creating a new product in the body of the create product form. Another service provided by this component is storing the products in an array that can be accessed and manipulated globally within the frontend of the application. Every time a product is created, it is written to the array as state which keeps track of all the data for that product along with a unique ID. Therefore, the provides interface for this component is to allow the store manager to create a new product by inputting its data into a form. Also, before storing the data regarding the newly created product in the global state array called products, the component also provides a service that validates the current stock count of the product and other input fields such as name, description, and price. Furthermore, the requires interface for this component is to send a low stock e-mail to the inbox of the manager if the current product has low stock and if a product is out of stock. If the stock count variable is set to 0, a separate e-mail is sent to the inbox of the manager saying that more stock is going to be ordered. Figure 1.1 below is a diagram that represents the above interface descriptions for the create product component.


Create Product Interface Description: The create product component has several functions that it provides for a new product to be created successfully without any errors being thrown, such as receiving data inputs for creating a new product in the body of the create product form. Another service provided by this component is storing the products in an array that can be accessed and manipulated globally within the frontend of the application. Every time a product is created, it is written to the array as state which keeps track of all the data for that product along with a unique ID. Therefore, the provides interface for this component is to allow the store manager to create a new product by inputting its data into a form. Also, before storing the data regarding the newly created product in the global state array called products, the component also provides a service that validates the current stock count of the product and other input fields such as name, description, and price. Furthermore, the requires interface for this component is to send a low stock e-mail to the inbox of the manager if the current product has low stock and if a product is out of stock. If the stock count variable is set to 0, a separate e-mail is sent to the inbox of the manager saying that more stock is going to be ordered. Figure 1.1 below is a diagram that represents the above interface descriptions for the create product component.

The create product component is to be developed solely using the JavaScript programming language, which utilises the Express JS framework for the backend and React JS as the frontend library which is going to be launched as a standalone microservice using Docker, also known as the frontend service. Moreover, these technologies are responsible for developing the create product component and rendering the data to the users through the frontend interface on the products page by interacting with the products backend service. Also, the most important safety conditions that must be met before the store manager is able to create a new product is that the name, description, price, and stock count input data is validated properly on the server-side, otherwise the server will throw an error back to the client and the component should validate the data being entered to prevent any errors and inconsistencies in the database. Below are all the pre and post condition assertions that the create product component must meet for the operations to succeed.

Pre-Condition 1:  The request body contains the required fields for creating a new product. Such as the name, description, price, stock count and is new property AND stock count >= 0

Post-Condition 1: New product created AND data written to the products database.

Post-Condition 2: Product details along with a success message are both returned with a 201 created resource status code.

Post-Condition 3: Stock count < 3 then low stock e-mail is sent to the manager inbox using an e-mail transporter using event broker.

Post-Condition 4: If any of the input fields are missing, an error message is returned in the response with a status code of 400 Bad Request.

The time condition for this create product component is that a new product must be created in less than 10 milliseconds without any timeouts coming from any upstream server. Finally, the next component description within this report is used to describe the concept of the product details component and its interface which renders new product promotions to the users on the platform.

## Component Name: Products List Module

Component Description: Rendering the product data from the database is one of the most important operations that this component must be able to achieve without any errors being thrown whilst the data is in transit. End-users must be able to view all the products which are currently in stock on the platform and click on the view details button which triggers an on click event that navigates the user to a different page called product details. The product details page is responsible for displaying the information regarding a single product such as the name, image, description and whether it is in stock or not. Allowing users to also add the product to their basket if they wish to proceed to place an order for the product. Furthermore, before rendering a list of products for the user to see on the screen, the component must undertake a couple of tasks before this. The component must first establish a connection to the products database for a GET request to be sent to the schema to retrieve all product details. Once this task is completed, the component must ensure that there are products available to display on the screen to the user. If there are products available, the server then returns a 200 OK status code which means that the request went through successfully with no errors along with the products in the form of JSON data.

Products List Interface Description: The products list functional component is being reused from a previous project. It has a couple of tasks that must be accomplished before rendering the products. One service that the component provides is a connection to the products database schema. This is the most important task that must be met before all the other tasks can be accomplished. After establishing a connection to the products database schema, the products list functional component which lives inside the frontend folder must be able to communicate with the products microservice whereby the component should be able to send a HTTP GET request to fetch all the products from the products microservice database schema. If no products are found then the server will still respond with a 200 OK status code, however an empty array will be returned instead of an error. Furthermore, global state management using react redux is being used to store the products data inside an array. Dispatching different actions such as fetch products or edit product details communicates with the products reducer which takes the global state variable products as its initial value and an action which is responsible for spreading out every state variable and storing the products in the payload of the request. Thus, when the products list page loads, a boolean flag set to true which loads the products.

The products list component is responsible for displaying all the available products that are stored in the products database schema by mapping through every single product and rendering each individual product data attribute for the user to see. Moreover, since all the components are developed using one language, then it is feasible to write the code using JavaScript instead of another language to keep things simple. The product list component must interact with the products backend REST API provided by the products microservice to manipulate the JSON data for every product that is returned to the client. However, the products microservice server must be active and listening for client requests before a GET request to fetch all products can successfully go through by hitting the specified endpoint. Furthermore, server-side validation is important to make sure that no errors are thrown unexpectedly. Before returning an array of products to the client in the form of JSON data, there is going to be an assertion which must always be true. Products must already be available in the products schema before returning them, otherwise a 400 bad request status code is returned. The product list component can also handle search queries for a specific product and whenever products with stock less than 3, then a low stock e-mail is sent to the managers inbox using the RabbitMQ event broker. Finally, based on the products list interface, below are the pre and post conditions that this component must always hold true to successfully achieve the functionality it is supposed to do, which is allow the frontend to talk to the products microservice considering fetching products by sending a GET request to an endpoint such as /api/v1/products.

Pre-Condition 1: Fetch Products Data: Active connection to products microservice database AND products array length > 0

Pre-Condition 2: Search Product: Product exists AND keyword present in the request query URI AND active connection to the products microservice database

Pre-Condition 3: Available Products (Count): Active connection to products microservice database AND number of products not equal to 0 AND product stock > 0

Pre-Condition 4: Products Exists: Active connection to products microservice database AND number of products not equal to 0

Post-Condition 1: Products microservice server returns 200 OK status code with populated products array

Post-Condition 2: Products server returns 200 OK status code with the searched product keyword coming from the request query.

Post-Condition 3: If no products are found in the products database, the server returns a 400 bad request status code.

Post-Condition 4: Products server returns the total number of products that are available per page.

This reusable component has a time condition which is that all the products must be fetched from the products database in less than 5 seconds, depending on the number of products. Finally, the next component description within this report describes the use case of creating an order.

# Monolith To Microservices & Design Approach

Web applications that adopt the monolithic architectural style are much faster to develop in the short-term because there may not be as many features to be developed. However, using this architecture is much easier to implement since code can be written within the entire codebase without taking into consideration modularity, robustness, or availability. The problem with this approach is that if one part of the application goes down due to a potential error then the entire application stops working. Thus, developers must pinpoint the main error that caused the crash, rectify it, and deploy it all over again. Therefore, this can potentially be very time consuming, instead time could be spent working on features that add value in the long run. TechRUs.dev is an e-commerce store that focuses on overcoming the issues with the monolithic architecture by incorporating a microservice oriented approach, like other e-commerce stores. This application is responsible for selling technology products that can be added to the user’s cart once they are authenticated with their account and orders can be placed.  Furthermore, once users add one or more products to their cart, they can proceed to the checkout page whereby they must provide their shipping details. This is necessary for placing orders. The frontend service that is listening for client requests on port 3000 communicates with the shipping microservice that is going to run on a pre-defined port to save the user’s details such as their address, phone number and city of residence by sending a POST request to the shipping server which then creates a new shipping resource by posting the data to the shipping schema. However, one disadvantage that has been taken into consideration of using the monolithic approach is scalability. As many more lines of code and service are incorporated within the application then it becomes much more difficult to maintain the code over a long period of time. As the application becomes less and less scalable, this can be very stressful for the developers because the code requires maintenance over time. 

The microservices architecture solves the issue of scalability in this regard which is a big advantage. Not only does this make the application more modular as the amount of code grows. But many more microservices can be added over time without compromising app availability. If one service goes down, such as the authentication service, then the rest of the application will not be affected by this. Hence, the e-commerce store that is being developed is going to support a variety of services that constitute as the main building blocks for the development of the store. Registering and logging in users is part of the authentication microservice, viewing product details and adding them to cart interacts with the products microservice. Placing product orders interacts with the orders microservice that has its own RESTful API that is consumed as well as a shipping service that allows the customers to provide their shipping details used for placing orders. Every single microservice is going to be built and deployed using independent and standalone docker containers that interacts with each service through their internal REST API. Docker allows microservices to be developed in isolation from others by building and launching containers out of images through various Docker files. Containers are used to package and deploy each microservice by encapsulating its dependencies. The e-commerce store that is to be developed is going to have one single docker file for every microservice such as authentication, products, orders, and shipping. Each docker file contains step by step instructions on how an image is to be built. Figure 1.1.2 below shows the microservices design for the whole e-commerce store with regards to the requirements. Each standalone microservice has its own MongoDB database schema that it connects to using the mongoose object relational mapper.

## Figure 1.1.2 – Microservice Architecture Design


<img width = "560" alt="image" src="https://user-images.githubusercontent.com/29733613/230736133-7fabbb35-3f8d-476e-ba41-27e7e1a14edf.png">


## Products - User Interface

The figure below shows the available products that are available to leave reviews and create orders for after adding one or more products to basket. This page is developed using two reusable components, one being the search bar that allows users to search for a product and the products that can be viewed in the middle of the page.

<img width = "550" alt="image" src="https://user-images.githubusercontent.com/29733613/230411959-6f0d1b97-f193-4210-85b5-b72071ade1eb.png">

## Figure 1.2 – Register Account User Interface

The figure below shows the Register user interface which allows customers to create their own account before verifying their e-mail address and logging in. It is important that customers are authenticated into the system before placing one or more orders for a product.

<img width = "560" alt="image" src="https://user-images.githubusercontent.com/29733613/230736182-6d3ed240-ffeb-4916-95a2-0ea0efbf7f2e.png">

## Figure 1.3 - Verify E-mail Address User Interface

The figure below shows the frontend user interface that allows customers to verify their e-mail address using a unique one-time passcode which is sent to their e-mail address to use for verification. The interface is developed using a reusable component called Email Verification that has been reused from a current group project.

<img width = "560" alt="image" src="https://user-images.githubusercontent.com/29733613/230736208-66d4589a-1bff-4790-acbf-fdbb1170bc24.png">

## Figure 1.4 - Login User Interface

The figure below shows the frontend user interface for the login page which is a requirement for this project. Customers must authenticate with their e-mail address and password. If they provide a wrong password that does not match the one stored in the database, then the customer is going to be displayed with an error message that’s processed as middleware within the authentication schema.

<img width="489" alt="image" src="https://user-images.githubusercontent.com/29733613/230736241-c99a5ae2-7a7d-4d11-8069-731b01cab5b0.png">

## Figure 1.5 - Product Details UI Component

The figure below shows the frontend user interface for a single product which is developed using a reusable component called Single Product from a previous project. This component allows customers to choose the quantity of this product they would like, also create one or more reviews as well as add it to their basket.

<img width = "570" alt="image" src="https://user-images.githubusercontent.com/29733613/230736260-5413957c-ee25-4ced-a843-97c08693a85c.png">

## Figure 1.6 - Basket Screen UI Component

The diagram below shows the frontend user interface which shows one or more products in the customer’s cart. They also could remove the product if they added the product by accident or if customers are no longer happy with their choice. After adding the product(s) to basket, customers must then proceed to the checkout page where they must fill out their shipping information.

<img width = "570" alt="image" src="https://user-images.githubusercontent.com/29733613/230736292-1569462d-74f6-4eac-8860-0fd81b1fab21.png">

## Figure 1.7 - Order Confirmation UI Component

The figure below shows the order confirmation page where users can place an order for the products they have chosen to purchase after adding them to cart. The frontend sends a POST request to the orders microservice which creates a new order resource on the server-side before saving it to the orders database.

<img width = "580" alt="image" src="https://user-images.githubusercontent.com/29733613/230736342-c2d4b5b0-7794-4188-b310-c46acffe7d38.png">

## Figure 1.8 - Logged In User Profile Component UI

The figure below shows the profile of the currently logged in user. They can view their username, e-mail address, start and end shift times. Moreover, users can update their password if they want to create a stronger one which is recommended for security reasons, or even update their profile that includes changing the username or e-mail address.


<img width = "590" alt="image" src="https://user-images.githubusercontent.com/29733613/230736363-cc23871a-8675-463b-8d58-cc83cb5342d1.png">

## Figure 1.9 - Edit User & Start Shift Dates

The diagram below shows how a user’s start and end shift dates can be altered using an in-built react library called date picker. Once the store manager (admin) has chosen the shift dates, a PUT request is sent to the authentication microservice that updates the user’s shifts given the user ID that’s currently logged in.


<img width = "580" alt="image" src="https://user-images.githubusercontent.com/29733613/230736386-a0c5c2ed-f7ca-49d1-b20a-4c13c2a6d84c.png">

## Figure 2.0 - Create Review UI Component

The diagram below shows the user interface that allows users to submit a review for a product after they have placed an order and paid for the specific product. Submitting the create review form will send a POST request to the reviews microservice API, whereby the server responds with a 201 created status code if the client request was successful.


<img width = "580" alt="image" src="https://user-images.githubusercontent.com/29733613/230736420-0fe50eeb-3c09-486d-9720-be920c8befa7.png">

# System Evaluation

Overall, the development of the e-commerce platform TechRUs has been very successful up to a large extent with close consideration of the systems quality, development cost and time taken. All but one of the requirements that were necessary for this project have been implemented and unit tested rigorously with all the tests passing that were outlined earlier within the test plan section. The application was designed, developed, and tested using the microservices architecture instead of a monolithic approach. Due to the number of advantages it has to offer. One main reason is enhanced scalability. An advantage of using MSOA is the ability to incorporate additional microservices into the application without hindering the availability, robustness, and modularity in a negative manner. Instead, it gives way to better modularity and reusability throughout the system. However, one drawback of using this architecture for developing the system is the extensive amount of time that has been spent on making sure that every microservice is running without any errors being thrown. Approximately, 2 weeks on average has been spent building, launching, and testing every microservice required for the system with little to no critical errors. Since each microservice has been built and launched using individual docker containers that are custom built from their associating images using a dockerfile. 

One major challenge encountered with this approach is the time spent waiting for the entire application to build and run. Thus, on average, 6-8 minutes has been spent waiting for the system to run with the microservices running concurrently which have been deployed on the ubuntu server rented out for £25 per month with no backups or load balancer. Thus, this is a significant cost for the development of this e-commerce store. Including the £10 domain name per annum. Moreover, another advantage taken into consideration of using MSOA to develop the system is that each service can easily be worked on independently. In the future, should there be individuals who would like to form a group to add more features to the project then this would be very easy for them because each developer can write and test their code on their chosen services. Without having to know all the ins and outs of other microservices such as authentication or orders. Finally, future work may include incorporating meta mask wallet integration that allows users to pay for one or more products using ether currency (ETH), whereby every single purchase transaction as part of an order would be inserted onto the blockchain. Rendering the platform even more secure, without having to worry about the payments service database being hacked. 


## Appendix 1.0 - Postman Register User API Response

<img width = "600" alt="image" src="https://user-images.githubusercontent.com/29733613/230736447-ec19cce6-ad05-4c86-91a3-2cfdeb51b0a2.png">

## Appendix 1.1 - Login User API Response

<img width = "600" alt="image" src="https://user-images.githubusercontent.com/29733613/230736519-52542458-1ae3-4f27-98bd-873fe6b2c904.png">

